<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>2048 - 4x4 区域轮换</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #faf8ef;
      margin: 0;
      padding: 20px 5px;
      box-sizing: border-box;
    }
    h1 {
      color: #776e65;
      margin: 0 0 15px 0;
      font-size: 2.5em;
    }
    #game-container {
      width: 90vw;
      max-width: 500px;
      margin: 0 auto;
      background-color: #bbada0;
      border-radius: 6px;
      padding: 2vw;
      position: relative;
      box-sizing: border-box;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 2vw;
      width: 100%;
      aspect-ratio: 1/1; /* 保持正方形比例 */
      box-sizing: border-box;
    }
    .cell {
      background-color: #cdc1b4;
      border-radius: 3px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #776e65;
      position: relative;
      box-sizing: border-box;
      transition: all 0.1s ease;
      font-size: min(7vw, 36px); /* 响应式字体大小 */
    }
    .inactive {
      background-color: #999 !important;
      color: #ddd !important;
      opacity: 0.8;
    }
    .active-border {
      border: 3px solid #ff0000;
    }
    .tile-2 { background-color: #eee4da; }
    .tile-4 { background-color: #ede0c8; }
    .tile-8 { background-color: #f2b179; color: white; }
    .tile-16 { background-color: #f59563; color: white; }
    .tile-32 { background-color: #f67c5f; color: white; }
    .tile-64 { background-color: #f65e3b; color: white; }
    .tile-128 { background-color: #edcf72; color: white; font-size: min(6vw, 30px); }
    .tile-256 { background-color: #edcc61; color: white; font-size: min(6vw, 30px); }
    .tile-512 { background-color: #edc850; color: white; font-size: min(6vw, 30px); }
    .tile-1024 { background-color: #edc53f; color: white; font-size: min(5vw, 26px); }
    .tile-2048 { background-color: #edc22e; color: white; font-size: min(5vw, 26px); }
    button {
      margin-top: 15px;
      padding: 12px 24px;
      font-size: 16px;
      background-color: #8f7a66;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background-color: #9f8a76;
    }
    #score {
      font-size: 1.2em;
      color: #776e65;
      margin-bottom: 10px;
    }
    #region-info {
      font-size: 1em;
      color: #776e65;
      margin-top: 5px;
      margin-bottom: 15px;
    }

    /* 确保在极小屏幕上也能正常显示 */
    @media (max-width: 320px) {
      h1 {
        font-size: 2em;
      }
      button {
        padding: 10px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <h1>2048 - 4x4 区域轮换</h1>
  <div id="score">得分: 0</div>
  <div id="region-info">当前区域: 左上</div>
  <div id="game-container">
    <div id="grid"></div>
  </div>
  <button onclick="restartGame()">重新开始</button>
  <script>
    const GRID_SIZE = 5; // 5x5 网格
    let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let score = 0;
    let currentRegionIndex = 0; // 0: 左上, 1: 右上, 2: 右下, 3: 左下
    // 4x4 区域在 5x5 网格中的起始位置
    const regions = [
      { r: 0, c: 0, name: "左上" }, // top-left
      { r: 0, c: 1, name: "右上" }, // top-right
      { r: 1, c: 1, name: "右下" }, // bottom-right
      { r: 1, c: 0, name: "左下" }  // bottom-left
    ];
    
    function createGrid() {
      const gridElement = document.getElementById("grid");
      gridElement.innerHTML = "";
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.id = `cell-${r}-${c}`;
          gridElement.appendChild(cell);
        }
      }
    }
    
    function getActiveRegion() {
      const { r, c } = regions[currentRegionIndex];
      const cells = [];
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          cells.push({ r: r + dr, c: c + dc });
        }
      }
      return cells;
    }
    
    function isActiveCell(r, c) {
      const region = getActiveRegion();
      return region.some(cell => cell.r === r && cell.c === c);
    }
    
    function updateView() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const value = grid[r][c];
          const cell = document.getElementById(`cell-${r}-${c}`);
          cell.className = "cell";
          if (!isActiveCell(r, c)) {
            cell.classList.add("inactive");
          } else if (r === regions[currentRegionIndex].r + 1 && c === regions[currentRegionIndex].c + 1) {
            cell.classList.add("active-border");
          }
          if (value !== 0) {
            const className = `tile-${Math.min(value, 2048)}`;
            cell.classList.add(className);
            cell.textContent = value;
          } else {
            cell.textContent = "";
          }
        }
      }
      document.getElementById("score").textContent = `得分: ${score}`;
      document.getElementById("region-info").textContent = `当前区域: ${regions[currentRegionIndex].name}`;
    }
    
    function addRandomTile() {
      const activeCells = getActiveRegion().filter(({ r, c }) => grid[r][c] === 0);
      if (activeCells.length > 0) {
        const { r, c } = activeCells[Math.floor(Math.random() * activeCells.length)];
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      }
    }
    
    // 移动函数 - 4x4 区域
    function moveLeftInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
          }
        }
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.push(0);
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) moved = true;
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }
    
    function moveRightInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
          }
        }
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.unshift(0);
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) moved = true;
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }
    
    function moveUpInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
          }
        }
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.push(0);
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) moved = true;
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }
    
    function moveDownInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
          }
        }
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.unshift(0);
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) moved = true;
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }
    
    function nextRegion() {
      currentRegionIndex = (currentRegionIndex + 1) % 4;
    }
    
    function isGameOver() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      // 检查当前 4x4 区域内是否有空格
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] === 0) return false;
        }
      }
      // 检查当前 4x4 区域内是否有可合并的相邻格子
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          const val = grid[startR + dr][startC + dc];
          // 检查下方（在区域内）
          if (dr < 3 && grid[startR + dr + 1][startC + dc] === val) return false;
          // 检查右方（在区域内）
          if (dc < 3 && grid[startR + dr][startC + dc + 1] === val) return false;
        }
      }
      return true; // 当前区域无法移动
    }
    
    function handleKeyDown(e) {
      const key = e.key;
      if (!["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(key)) return;
      e.preventDefault();
      let moved = false;
      switch (key) {
        case "ArrowLeft": moved = moveLeftInRegion(); break;
        case "ArrowRight": moved = moveRightInRegion(); break;
        case "ArrowUp": moved = moveUpInRegion(); break;
        case "ArrowDown": moved = moveDownInRegion(); break;
      }
      if (moved) {
        nextRegion();
        addRandomTile();
        updateView();
        if (isGameOver()) {
          setTimeout(() => {
            alert("当前4x4区域已满且无法合并！游戏结束！\n你的得分是: " + score);
          }, 150);
        }
      }
    }
    
    // 添加触摸滑动支持
    let touchStartX = 0;
    let touchStartY = 0;
    
    function handleTouchStart(e) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
    
    function handleTouchMove(e) {
      e.preventDefault(); // 防止页面滚动
    }
    
    function handleTouchEnd(e) {
      if (!touchStartX || !touchStartY) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      
      // 确定滑动方向（优先考虑滑动距离更长的方向）
      if (Math.abs(diffX) > Math.abs(diffY)) {
        // 水平滑动
        if (Math.abs(diffX) > 30) { // 最小滑动距离阈值
          if (diffX > 0) {
            moveRightInRegion();
          } else {
            moveLeftInRegion();
          }
        }
      } else {
        // 垂直滑动
        if (Math.abs(diffY) > 30) { // 最小滑动距离阈值
          if (diffY > 0) {
            moveDownInRegion();
          } else {
            moveUpInRegion();
          }
        }
      }
      
      // 重置触摸起始位置
      touchStartX = 0;
      touchStartY = 0;
      
      // 检查是否有移动并更新游戏状态
      if (moved) {
        nextRegion();
        addRandomTile();
        updateView();
        if (isGameOver()) {
          setTimeout(() => {
            alert("当前4x4区域已满且无法合并！游戏结束！\n你的得分是: " + score);
          }, 150);
        }
      }
    }
    
    function restartGame() {
      grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      score = 0;
      currentRegionIndex = 0;
      addRandomTile();
      addRandomTile();
      updateView();
    }
    
    // 初始化事件监听
    window.addEventListener("keydown", handleKeyDown);
    document.addEventListener("touchstart", handleTouchStart, false);
    document.addEventListener("touchmove", handleTouchMove, false);
    document.addEventListener("touchend", handleTouchEnd, false);
    
    // 防止移动端双击缩放
    document.addEventListener('dblclick', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    createGrid();
    restartGame();
  </script>
</body>
</html>