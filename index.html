<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>2048 - 4x4 区域轮换</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #faf8ef;
      margin: 0;
      padding: 20px 5px;
      box-sizing: border-box;
    }
    h1 {
      color: #776e65;
      margin: 0 0 15px 0;
      font-size: 2.5em;
    }
    #game-container {
      width: 90vw;
      max-width: 500px;
      margin: 0 auto;
      background-color: #bbada0;
      border-radius: 6px;
      padding: 2vw;
      position: relative;
      box-sizing: border-box;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 2vw;
      width: 100%;
      aspect-ratio: 1/1;
      box-sizing: border-box;
    }
    .cell {
      background-color: #cdc1b4;
      border-radius: 3px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #776e65;
      position: relative;
      box-sizing: border-box;
      transition: all 0.1s ease;
      font-size: min(7vw, 36px);
    }
    .inactive {
      background-color: #999 !important;
      color: #ddd !important;
      opacity: 0.8;
    }
    .active-border {
      border: 3px solid #ff0000;
    }
    .tile-2 { background-color: #eee4da; }
    .tile-4 { background-color: #ede0c8; }
    .tile-8 { background-color: #f2b179; color: white; }
    .tile-16 { background-color: #f59563; color: white; }
    .tile-32 { background-color: #f67c5f; color: white; }
    .tile-64 { background-color: #f65e3b; color: white; }
    .tile-128 { background-color: #edcf72; color: white; font-size: min(6vw, 30px); }
    .tile-256 { background-color: #edcc61; color: white; font-size: min(6vw, 30px); }
    .tile-512 { background-color: #edc850; color: white; font-size: min(6vw, 30px); }
    .tile-1024 { background-color: #edc53f; color: white; font-size: min(5vw, 26px); }
    .tile-2048 { background-color: #edc22e; color: white; font-size: min(5vw, 26px); }
    .button-container {
      margin-top: 15px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      background-color: #8f7a66;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background-color: #9f8a76;
    }
    #score {
      font-size: 1.2em;
      color: #776e65;
      margin-bottom: 10px;
    }
    #region-info {
      font-size: 1em;
      color: #776e65;
      margin-top: 5px;
      margin-bottom: 15px;
    }
    @media (max-width: 320px) {
      h1 {
        font-size: 2em;
      }
      button {
        padding: 10px 20px;
        font-size: 14px;
      }
      .button-container {
        flex-direction: column;
        align-items: center;
      }
      button {
        width: 80%;
      }
    }
  </style>
</head>
<body>
  <h1>2048 - 4x4 区域轮换</h1>
  <div id="score">得分: 0</div>
  <div id="region-info">当前区域: 左上</div>
  <div id="game-container">
    <div id="grid"></div>
  </div>
  <div class="button-container">
    <button onclick="restartGame()">重新开始</button>
    <button onclick="toggleMusic()">关闭音乐</button>
  </div>

  <!-- 背景音乐 -->
  <audio id="background-music" loop>
    <source src="不说.mp3" type="audio/mpeg">
    您的浏览器不支持音频播放。
  </audio>

  <script>
    const GRID_SIZE = 5;
    let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let score = 0;
    let currentRegionIndex = 0;
    let musicPlaying = false;

    const regions = [
      { r: 0, c: 0, name: "左上" },
      { r: 0, c: 1, name: "右上" },
      { r: 1, c: 1, name: "右下" },
      { r: 1, c: 0, name: "左下" }
    ];

    function createGrid() {
      const gridElement = document.getElementById("grid");
      gridElement.innerHTML = "";
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.id = `cell-${r}-${c}`;
          gridElement.appendChild(cell);
        }
      }
    }

    function getActiveRegion() {
      const { r, c } = regions[currentRegionIndex];
      const cells = [];
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          cells.push({ r: r + dr, c: c + dc });
        }
      }
      return cells;
    }

    function isActiveCell(r, c) {
      const region = getActiveRegion();
      return region.some(cell => cell.r === r && cell.c === c);
    }

    function updateView() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const value = grid[r][c];
          const cell = document.getElementById(`cell-${r}-${c}`);
          cell.className = "cell";
          if (!isActiveCell(r, c)) {
            cell.classList.add("inactive");
          } else if (r === regions[currentRegionIndex].r + 1 && c === regions[currentRegionIndex].c + 1) {
            cell.classList.add("active-border");
          }
          if (value !== 0) {
            const className = `tile-${Math.min(value, 2048)}`;
            cell.classList.add(className);
            cell.textContent = value;
          } else {
            cell.textContent = "";
          }
        }
      }
      document.getElementById("score").textContent = `得分: ${score}`;
      document.getElementById("region-info").textContent = `当前区域: ${regions[currentRegionIndex].name}`;
    }

    function addRandomTile() {
      const activeCells = getActiveRegion().filter(({ r, c }) => grid[r][c] === 0);
      if (activeCells.length > 0) {
        const { r, c } = activeCells[Math.floor(Math.random() * activeCells.length)];
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function moveLeftInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
          }
        }
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.push(0);
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) moved = true;
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }

    function moveRightInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
          }
        }
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.unshift(0);
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) moved = true;
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }

    function moveUpInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
          }
        }
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.push(0);
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) moved = true;
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }

    function moveDownInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
          }
        }
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.unshift(0);
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) moved = true;
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }

    function nextRegion() {
      currentRegionIndex = (currentRegionIndex + 1) % 4;
    }

    function isGameOver() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] === 0) return false;
        }
      }
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          const val = grid[startR + dr][startC + dc];
          if (dr < 3 && grid[startR + dr + 1][startC + dc] === val) return false;
          if (dc < 3 && grid[startR + dr][startC + dc + 1] === val) return false;
        }
      }
      return true;
    }

    // 键盘控制
    function handleKeyDown(e) {
      const key = e.key;
      if (!["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(key)) return;
      e.preventDefault();
      let moved = false;
      switch (key) {
        case "ArrowLeft": moved = moveLeftInRegion(); break;
        case "ArrowRight": moved = moveRightInRegion(); break;
        case "ArrowUp": moved = moveUpInRegion(); break;
        case "ArrowDown": moved = moveDownInRegion(); break;
      }
      if (moved) {
        nextRegion();
        addRandomTile();
        updateView();
        if (isGameOver()) {
          setTimeout(() => {
            alert("当前4x4区域已满且无法合并！游戏结束！\n你的得分是: " + score);
          }, 150);
        }
      }
    }

    // 触摸控制
    let touchStartX = 0;
    let touchStartY = 0;

    function handleTouchStart(e) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }

    function handleTouchMove(e) {
      e.preventDefault();
    }

    function handleTouchEnd(e) {
      if (!touchStartX || !touchStartY) return;

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;

      let moved = false;

      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (Math.abs(diffX) > 30) {
          if (diffX > 0) {
            moved = moveRightInRegion();
          } else {
            moved = moveLeftInRegion();
          }
        }
      } else {
        if (Math.abs(diffY) > 30) {
          if (diffY > 0) {
            moved = moveDownInRegion();
          } else {
            moved = moveUpInRegion();
          }
        }
      }

      touchStartX = 0;
      touchStartY = 0;

      if (moved) {
        nextRegion();
        addRandomTile();
        updateView();
        if (isGameOver()) {
          setTimeout(() => {
            alert("当前4x4区域已满且无法合并！游戏结束！\n你的得分是: " + score);
          }, 150);
        }
      }
    }

    // 音乐控制
    function toggleMusic() {
      const music = document.getElementById('background-music');
      const musicButton = document.querySelector('button[onclick="toggleMusic()"]');
      
      if (musicPlaying) {
        music.pause();
        musicPlaying = false;
        musicButton.textContent = "播放音乐";
      } else {
        const playPromise = music.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            musicPlaying = true;
            musicButton.textContent = "关闭音乐";
            console.log('背景音乐已播放');
          }).catch(error => {
            console.warn('音频播放被阻止:', error);
            alert('请允许音频播放权限');
          });
        }
      }
    }

    // 重启游戏
    function restartGame() {
      grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      score = 0;
      currentRegionIndex = 0;
      addRandomTile();
      addRandomTile();
      updateView();

      // 尝试播放背景音乐
      const music = document.getElementById('background-music');
      const musicButton = document.querySelector('button[onclick="toggleMusic()"]');
      
      const playPromise = music.play();
      if (playPromise !== undefined) {
        playPromise.then(() => {
          musicPlaying = true;
          musicButton.textContent = "关闭音乐";
          console.log('背景音乐已播放');
        }).catch(error => {
          console.warn('音频播放被阻止:', error);
          musicPlaying = false;
          musicButton.textContent = "播放音乐";
        });
      }
    }

    // 初始化
    window.addEventListener("keydown", handleKeyDown);
    document.addEventListener("touchstart", handleTouchStart, { passive: true });
    document.addEventListener("touchmove", handleTouchMove, { passive: false });
    document.addEventListener("touchend", handleTouchEnd, { passive: true });
    document.addEventListener('dblclick', function(e) {
      e.preventDefault();
    }, { passive: false });

    createGrid();
    restartGame();
  </script>
</body>
</html>