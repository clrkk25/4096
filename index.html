<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>2048 - 4x4 区域轮换</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #faf8ef;
      margin: 0;
      padding: 15px 5px;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
    }
    h1 {
      color: #776e65;
      margin: 0 0 15px 0;
      font-size: clamp(2em, 8vw, 2.5em); /* 响应式标题 */
    }
    #game-container {
      width: 92vw;
      max-width: 500px;
      margin: 0 auto;
      background-color: #bbada0;
      border-radius: 6px;
      padding: 2vw;
      position: relative;
      box-sizing: border-box;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* 增加阴影提升质感 */
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 2vw;
      width: 100%;
      aspect-ratio: 1/1; /* 保持正方形比例 */
      box-sizing: border-box;
    }
    .cell {
      background-color: #cdc1b4;
      border-radius: 3px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #776e65;
      position: relative;
      box-sizing: border-box;
      transition: all 0.1s ease;
      font-size: min(7vw, 36px); /* 响应式字体大小 */
    }
    .inactive {
      background-color: #999 !important;
      color: #ddd !important;
      opacity: 0.8;
    }
    .active-border {
      border: 3px solid #ff0000;
      box-shadow: 0 0 0 2px rgba(255,0,0,0.3); /* 增加边框阴影 */
    }
    .tile-2 { background-color: #eee4da; }
    .tile-4 { background-color: #ede0c8; }
    .tile-8 { background-color: #f2b179; color: white; }
    .tile-16 { background-color: #f59563; color: white; }
    .tile-32 { background-color: #f67c5f; color: white; }
    .tile-64 { background-color: #f65e3b; color: white; }
    .tile-128 { background-color: #edcf72; color: white; font-size: min(6vw, 30px); }
    .tile-256 { background-color: #edcc61; color: white; font-size: min(6vw, 30px); }
    .tile-512 { background-color: #edc850; color: white; font-size: min(6vw, 30px); }
    .tile-1024 { background-color: #edc53f; color: white; font-size: min(5vw, 26px); }
    .tile-2048 { background-color: #edc22e; color: white; font-size: min(5vw, 26px); }
    .tile-super { background-color: #3c3a32; color: white; font-size: min(5vw, 26px); } /* 超过2048的数字 */
    
    .control-buttons {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 15px auto;
      max-width: 300px;
    }
    
    button {
      padding: 12px 24px;
      font-size: 16px;
      background-color: #8f7a66;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    button:hover, button:active {
      background-color: #9f8a76;
    }
    
    #mobile-controls {
      display: none;
      margin: 20px auto 10px;
      width: 200px;
      height: 200px;
      position: relative;
    }
    
    .direction-btn {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 5px;
      background-color: #8f7a66;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      user-select: none;
    }
    
    #up-btn { top: 0; left: 70px; }
    #left-btn { top: 70px; left: 0; }
    #down-btn { top: 140px; left: 70px; }
    #right-btn { top: 70px; left: 140px; }
    
    #score {
      font-size: 1.2em;
      color: #776e65;
      margin-bottom: 10px;
      font-weight: bold;
    }
    #region-info {
      font-size: 1em;
      color: #776e65;
      margin-top: 5px;
      margin-bottom: 15px;
    }
    
    /* 动画效果 */
    @keyframes tile-appear {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .tile-merged {
      animation: tile-appear 0.2s ease;
    }
    
    /* 响应式调整 */
    @media (max-width: 768px) {
      #mobile-controls {
        display: block;
      }
      
      .control-buttons {
        flex-wrap: wrap;
      }
    }
    
    @media (max-width: 320px) {
      h1 {
        font-size: 2em;
      }
      button {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      #mobile-controls {
        width: 160px;
        height: 160px;
      }
      
      .direction-btn {
        width: 50px;
        height: 50px;
      }
      
      #up-btn { top: 0; left: 55px; }
      #left-btn { top: 55px; left: 0; }
      #down-btn { top: 110px; left: 55px; }
      #right-btn { top: 55px; left: 110px; }
    }
  </style>
</head>
<body>
  <h1>2048 - 4x4 区域轮换</h1>
  <div id="score">得分: 0</div>
  <div id="region-info">当前区域: 左上</div>
  <div id="game-container">
    <div id="grid"></div>
  </div>
  
  <!-- 移动端方向控制按钮 -->
  <div id="mobile-controls">
    <div class="direction-btn" id="up-btn">↑</div>
    <div class="direction-btn" id="left-btn">←</div>
    <div class="direction-btn" id="down-btn">↓</div>
    <div class="direction-btn" id="right-btn">→</div>
  </div>
  
  <div class="control-buttons">
    <button onclick="restartGame()">重新开始</button>
    <button onclick="undoMove()">撤销</button>
  </div>
  
  <script>
    const GRID_SIZE = 5; // 5x5 网格
    let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let score = 0;
    let currentRegionIndex = 0; // 0: 左上, 1: 右上, 2: 右下, 3: 左下
    let gameHistory = []; // 用于撤销功能
    
    // 4x4 区域在 5x5 网格中的起始位置
    const regions = [
      { r: 0, c: 0, name: "左上" }, // top-left
      { r: 0, c: 1, name: "右上" }, // top-right
      { r: 1, c: 1, name: "右下" }, // bottom-right
      { r: 1, c: 0, name: "左下" }  // bottom-left
    ];
    
    function createGrid() {
      const gridElement = document.getElementById("grid");
      gridElement.innerHTML = "";
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.id = `cell-${r}-${c}`;
          gridElement.appendChild(cell);
        }
      }
    }
    
    function getActiveRegion() {
      const { r, c } = regions[currentRegionIndex];
      const cells = [];
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          cells.push({ r: r + dr, c: c + dc });
        }
      }
      return cells;
    }
    
    function isActiveCell(r, c) {
      const region = getActiveRegion();
      return region.some(cell => cell.r === r && cell.c === c);
    }
    
    function updateView() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const value = grid[r][c];
          const cell = document.getElementById(`cell-${r}-${c}`);
          cell.className = "cell";
          
          if (!isActiveCell(r, c)) {
            cell.classList.add("inactive");
          } else if (r === regions[currentRegionIndex].r + 1 && c === regions[currentRegionIndex].c + 1) {
            cell.classList.add("active-border");
          }
          
          if (value !== 0) {
            let className;
            if (value <= 2048) {
              className = `tile-${value}`;
            } else {
              className = 'tile-super';
            }
            cell.classList.add(className);
            cell.textContent = value;
            
            // 检查是否是新合并的 tile 并添加动画
            if (cell.classList.contains('tile-merged')) {
              setTimeout(() => {
                cell.classList.remove('tile-merged');
              }, 200);
            }
          } else {
            cell.textContent = "";
          }
        }
      }
      document.getElementById("score").textContent = `得分: ${score}`;
      document.getElementById("region-info").textContent = `当前区域: ${regions[currentRegionIndex].name}`;
    }
    
    function saveGameState() {
      // 保存当前游戏状态用于撤销
      gameHistory.push({
        grid: JSON.parse(JSON.stringify(grid)),
        score: score,
        regionIndex: currentRegionIndex
      });
      
      // 限制历史记录长度，防止内存占用过大
      if (gameHistory.length > 10) {
        gameHistory.shift();
      }
    }
    
    function undoMove() {
      if (gameHistory.length > 0) {
        const lastState = gameHistory.pop();
        grid = lastState.grid;
        score = lastState.score;
        currentRegionIndex = lastState.regionIndex;
        updateView();
      }
    }
    
    function addRandomTile() {
      const activeCells = getActiveRegion().filter(({ r, c }) => grid[r][c] === 0);
      if (activeCells.length > 0) {
        const { r, c } = activeCells[Math.floor(Math.random() * activeCells.length)];
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
        
        // 为新出现的 tile 添加动画
        setTimeout(() => {
          const cell = document.getElementById(`cell-${r}-${c}`);
          cell.classList.add('tile-merged');
        }, 50);
      }
    }
    
    // 移动函数 - 4x4 区域
    function moveLeftInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        let merged = false;
        
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
            merged = true;
          }
        }
        
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.push(0);
        
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) {
            moved = true;
            
            // 如果是合并产生的变化，添加动画
            if (merged && newRow[dc] !== 0) {
              setTimeout(() => {
                const cell = document.getElementById(`cell-${startR + dr}-${startC + dc}`);
                cell.classList.add('tile-merged');
              }, 50);
            }
          }
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }
    
    function moveRightInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      
      for (let dr = 0; dr < 4; dr++) {
        const row = [
          grid[startR+dr][startC], 
          grid[startR+dr][startC+1], 
          grid[startR+dr][startC+2],
          grid[startR+dr][startC+3]
        ];
        const filtered = row.filter(val => val !== 0);
        let merged = false;
        
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
            merged = true;
          }
        }
        
        const newRow = filtered.filter(val => val !== 0);
        while (newRow.length < 4) newRow.unshift(0);
        
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] !== newRow[dc]) {
            moved = true;
            
            // 如果是合并产生的变化，添加动画
            if (merged && newRow[dc] !== 0) {
              setTimeout(() => {
                const cell = document.getElementById(`cell-${startR + dr}-${startC + dc}`);
                cell.classList.add('tile-merged');
              }, 50);
            }
          }
          grid[startR + dr][startC + dc] = newRow[dc];
        }
      }
      return moved;
    }
    
    function moveUpInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        let merged = false;
        
        for (let i = 0; i < filtered.length - 1; i++) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i] *= 2;
            score += filtered[i];
            filtered[i + 1] = 0;
            moved = true;
            merged = true;
          }
        }
        
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.push(0);
        
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) {
            moved = true;
            
            // 如果是合并产生的变化，添加动画
            if (merged && newCol[dr] !== 0) {
              setTimeout(() => {
                const cell = document.getElementById(`cell-${startR + dr}-${startC + dc}`);
                cell.classList.add('tile-merged');
              }, 50);
            }
          }
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }
    
    function moveDownInRegion() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      let moved = false;
      
      for (let dc = 0; dc < 4; dc++) {
        const col = [
          grid[startR][startC+dc], 
          grid[startR+1][startC+dc], 
          grid[startR+2][startC+dc],
          grid[startR+3][startC+dc]
        ];
        const filtered = col.filter(val => val !== 0);
        let merged = false;
        
        for (let i = filtered.length - 2; i >= 0; i--) {
          if (filtered[i] === filtered[i + 1]) {
            filtered[i + 1] *= 2;
            score += filtered[i + 1];
            filtered[i] = 0;
            moved = true;
            merged = true;
          }
        }
        
        const newCol = filtered.filter(val => val !== 0);
        while (newCol.length < 4) newCol.unshift(0);
        
        for (let dr = 0; dr < 4; dr++) {
          if (grid[startR + dr][startC + dc] !== newCol[dr]) {
            moved = true;
            
            // 如果是合并产生的变化，添加动画
            if (merged && newCol[dr] !== 0) {
              setTimeout(() => {
                const cell = document.getElementById(`cell-${startR + dr}-${startC + dc}`);
                cell.classList.add('tile-merged');
              }, 50);
            }
          }
          grid[startR + dr][startC + dc] = newCol[dr];
        }
      }
      return moved;
    }
    
    function nextRegion() {
      currentRegionIndex = (currentRegionIndex + 1) % 4;
    }
    
    function isGameOver() {
      const { r: startR, c: startC } = regions[currentRegionIndex];
      // 检查当前 4x4 区域内是否有空格
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          if (grid[startR + dr][startC + dc] === 0) return false;
        }
      }
      // 检查当前 4x4 区域内是否有可合并的相邻格子
      for (let dr = 0; dr < 4; dr++) {
        for (let dc = 0; dc < 4; dc++) {
          const val = grid[startR + dr][startC + dc];
          // 检查下方（在区域内）
          if (dr < 3 && grid[startR + dr + 1][startC + dc] === val) return false;
          // 检查右方（在区域内）
          if (dc < 3 && grid[startR + dr][startC + dc + 1] === val) return false;
        }
      }
      return true; // 当前区域无法移动
    }
    
    function handleMove(direction) {
      saveGameState(); // 保存移动前的状态
      let moved = false;
      
      switch (direction) {
        case "left": moved = moveLeftInRegion(); break;
        case "right": moved = moveRightInRegion(); break;
        case "up": moved = moveUpInRegion(); break;
        case "down": moved = moveDownInRegion(); break;
      }
      
      if (moved) {
        nextRegion();
        addRandomTile();
        updateView();
        if (isGameOver()) {
          setTimeout(() => {
            if (confirm(`当前4x4区域已满且无法合并！游戏结束！\n你的得分是: ${score}\n是否重新开始？`)) {
              restartGame();
            }
          }, 150);
        }
      }
    }
    
    function handleKeyDown(e) {
      const key = e.key;
      if (!["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(key)) return;
      e.preventDefault();
      
      switch (key) {
        case "ArrowLeft": handleMove("left"); break;
        case "ArrowRight": handleMove("right"); break;
        case "ArrowUp": handleMove("up"); break;
        case "ArrowDown": handleMove("down"); break;
      }
    }
    
    // 触摸滑动支持 - 优化版
    let touchStartX = 0;
    let touchStartY = 0;
    let touchTimeStart = 0;
    const MIN_SWIPE_DISTANCE = 30; // 最小滑动距离
    const MAX_SWIPE_TIME = 500; // 最大滑动时间（毫秒）
    
    function handleTouchStart(e) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchTimeStart = new Date().getTime();
    }
    
    function handleTouchMove(e) {
      // 防止触摸滑动时页面滚动
      if (Math.abs(e.touches[0].clientX - touchStartX) > 10 || 
          Math.abs(e.touches[0].clientY - touchStartY) > 10) {
        e.preventDefault();
      }
    }
    
    function handleTouchEnd(e) {
      if (!touchStartX || !touchStartY) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const touchTimeEnd = new Date().getTime();
      const touchTime = touchTimeEnd - touchTimeStart;
      
      // 计算滑动距离
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      
      // 重置触摸起始位置
      touchStartX = 0;
      touchStartY = 0;
      
      // 检查滑动是否有效（距离和时间）
      if (touchTime > MAX_SWIPE_TIME) {
        return; // 滑动时间过长，视为无效
      }
      
      // 确定滑动方向（优先考虑滑动距离更长的方向）
      if (Math.abs(diffX) > Math.abs(diffY)) {
        // 水平滑动
        if (Math.abs(diffX) > MIN_SWIPE_DISTANCE) {
          if (diffX > 0) {
            handleMove("right");
          } else {
            handleMove("left");
          }
        }
      } else {
        // 垂直滑动
        if (Math.abs(diffY) > MIN_SWIPE_DISTANCE) {
          if (diffY > 0) {
            handleMove("down");
          } else {
            handleMove("up");
          }
        }
      }
    }
    
    function restartGame() {
      grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      score = 0;
      currentRegionIndex = 0;
      gameHistory = []; // 清空历史记录
      addRandomTile();
      addRandomTile();
      updateView();
    }
    
    // 初始化事件监听
    window.addEventListener("keydown", handleKeyDown);
    document.addEventListener("touchstart", handleTouchStart, { passive: true });
    document.addEventListener("touchmove", handleTouchMove, { passive: false });
    document.addEventListener("touchend", handleTouchEnd, { passive: true });
    
    // 防止移动端双击缩放
    document.addEventListener('dblclick', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    // 为移动控制按钮添加点击事件
    document.getElementById('up-btn').addEventListener('click', () => handleMove('up'));
    document.getElementById('left-btn').addEventListener('click', () => handleMove('left'));
    document.getElementById('down-btn').addEventListener('click', () => handleMove('down'));
    document.getElementById('right-btn').addEventListener('click', () => handleMove('right'));
    
    // 初始化游戏
    createGrid();
    restartGame();
  </script>
</body>
</html>